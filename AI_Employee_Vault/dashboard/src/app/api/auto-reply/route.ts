import { NextResponse } from 'next/server';
import * as fs from 'fs';
import * as path from 'path';
import * as nodemailer from 'nodemailer';

const VAULT_PATH = process.env.VAULT_PATH || path.resolve(process.cwd(), '..');

// Email configuration
const EMAIL_CONFIG = {
  host: process.env.SMTP_HOST || 'smtp.gmail.com',
  port: parseInt(process.env.SMTP_PORT || '587'),
  secure: process.env.SMTP_SECURE === 'true',
  auth: {
    user: process.env.SMTP_USER || process.env.GMAIL_USER || '',
    pass: process.env.SMTP_PASS || process.env.GMAIL_APP_PASSWORD || '',
  },
};

// Generate AI-style reply based on email content
function generateReply(from: string, subject: string, snippet: string): string {
  // Extract sender name from email
  const senderName = from.includes('<')
    ? from.split('<')[0].trim().replace(/"/g, '')
    : from.split('@')[0];

  // Determine reply type based on subject/content
  const lowerSubject = subject.toLowerCase();
  const lowerSnippet = snippet.toLowerCase();

  let greeting = `Dear ${senderName},`;
  let body = '';
  let closing = 'Best regards';

  // Job-related emails
  if (lowerSubject.includes('job') || lowerSubject.includes('intern') ||
      lowerSubject.includes('developer') || lowerSubject.includes('position') ||
      lowerSnippet.includes('job') || lowerSnippet.includes('opportunity')) {
    body = `Thank you for reaching out regarding "${subject}".

I have reviewed the opportunity and appreciate you thinking of me. I will carefully consider this and get back to you if I would like to proceed further.

Thank you for your time and consideration.`;
  }
  // Invoice/Payment related
  else if (lowerSubject.includes('invoice') || lowerSubject.includes('payment') ||
           lowerSubject.includes('bill') || lowerSnippet.includes('payment')) {
    body = `Thank you for your email regarding "${subject}".

I have received this and will review the details. If any action is required from my end, I will process it promptly.

Please let me know if you need any additional information.`;
  }
  // Meeting/Calendar related
  else if (lowerSubject.includes('meeting') || lowerSubject.includes('call') ||
           lowerSubject.includes('schedule') || lowerSnippet.includes('meeting')) {
    body = `Thank you for your email about "${subject}".

I have noted this in my calendar and will confirm my availability shortly. Please feel free to suggest alternative times if needed.`;
  }
  // Alert/Notification emails
  else if (lowerSubject.includes('alert') || lowerSubject.includes('notification') ||
           lowerSubject.includes('security') || from.includes('noreply') || from.includes('no-reply')) {
    body = `Thank you for the notification regarding "${subject}".

I have received and acknowledged this alert. No further action is required at this time.`;
  }
  // General response
  else {
    body = `Thank you for your email regarding "${subject}".

I have received your message and will review it carefully. I will get back to you with a detailed response as soon as possible.

Please let me know if you need anything else in the meantime.`;
  }

  return `${greeting}

${body}

${closing}`;
}

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { emailId, from, subject, snippet } = body;

    if (!emailId || !from || !subject) {
      return NextResponse.json(
        { error: 'Missing required fields: emailId, from, subject' },
        { status: 400 }
      );
    }

    // Generate reply content
    const replyBody = generateReply(from, subject, snippet || '');
    const replySubject = subject.startsWith('Re:') ? subject : `Re: ${subject}`;

    // Extract email address from "Name <email>" format
    const toEmail = from.includes('<')
      ? from.match(/<([^>]+)>/)?.[1] || from
      : from;

    console.log('Auto-reply details:', { to: toEmail, subject: replySubject });

    // Check if SMTP is configured
    if (!EMAIL_CONFIG.auth.user || !EMAIL_CONFIG.auth.pass) {
      // Save as draft instead of sending
      const timestamp = new Date().toISOString();
      const draftId = `auto_reply_${Date.now()}`;

      const draftContent = `---
type: email_draft
status: pending
created: ${timestamp}
title: ${replySubject}
to: ${toEmail}
subject: ${replySubject}
original_email_id: ${emailId}
auto_generated: true
---

## Auto-Generated Reply

**To:** ${toEmail}
**Subject:** ${replySubject}

### Body

${replyBody}

---
*Auto-generated by AI Employee. SMTP not configured - saved as draft.*
`;

      const approvalsPath = path.join(VAULT_PATH, 'Approvals');
      if (!fs.existsSync(approvalsPath)) {
        fs.mkdirSync(approvalsPath, { recursive: true });
      }
      fs.writeFileSync(path.join(approvalsPath, `${draftId}.md`), draftContent);

      return NextResponse.json({
        success: true,
        sent: false,
        savedAsDraft: true,
        message: 'SMTP not configured. Reply saved as draft for manual sending.',
        draftId,
      });
    }

    // Send email via SMTP
    try {
      const transporter = nodemailer.createTransport(EMAIL_CONFIG);

      await transporter.sendMail({
        from: EMAIL_CONFIG.auth.user,
        to: toEmail,
        subject: replySubject,
        text: replyBody,
        html: replyBody.replace(/\n/g, '<br>'),
      });

      // Archive the original email
      const emailsPath = path.join(VAULT_PATH, 'Needs_Action', 'Emails');
      const originalFile = path.join(emailsPath, `${emailId}.md`);

      if (fs.existsSync(originalFile)) {
        const donePath = path.join(VAULT_PATH, 'Done', 'Emails');
        if (!fs.existsSync(donePath)) {
          fs.mkdirSync(donePath, { recursive: true });
        }

        // Add reply info to the file before moving
        let content = fs.readFileSync(originalFile, 'utf-8');
        content += `\n\n---\n## Auto-Reply Sent\n**Date:** ${new Date().toISOString()}\n**To:** ${toEmail}\n\n${replyBody}\n`;
        fs.writeFileSync(originalFile, content);

        fs.renameSync(originalFile, path.join(donePath, `${emailId}.md`));
      }

      // Log the action
      const logsPath = path.join(VAULT_PATH, 'Logs');
      if (!fs.existsSync(logsPath)) {
        fs.mkdirSync(logsPath, { recursive: true });
      }
      const today = new Date().toISOString().split('T')[0];
      const logFile = path.join(logsPath, `daily_${today}.log`);
      fs.appendFileSync(logFile,
        `[${new Date().toISOString()}] [INFO] Auto-reply sent to ${toEmail}: ${replySubject}\n`
      );

      return NextResponse.json({
        success: true,
        sent: true,
        message: `Reply sent to ${toEmail}`,
        to: toEmail,
        subject: replySubject,
      });

    } catch (emailError: any) {
      console.error('SMTP error:', emailError);
      return NextResponse.json({
        success: false,
        error: `SMTP error: ${emailError.message}`,
      });
    }

  } catch (error: any) {
    console.error('Auto-reply API error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to process auto-reply' },
      { status: 500 }
    );
  }
}
